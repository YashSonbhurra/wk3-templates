{{FrontSide}}

<!--
The Template is divided into sections.
Sections get turned off based on which Card Type is displayed.
-->

<div id=card-back>

<!--Radical Combination Section-->
<!--For: Kanji-->
<div id=section-radical-combination>
	Radical Combination<hr>
	<div id=combination></div>
</div>

<!--Meaning Section-->
<!--For: Radical, Kanji, Vocabulary-->

<div id=section-meaning>
	<div id=meaning-title></div>
	<p id=meanings></p>
	<p class="explanation">Explanation</p>
	<div class="mnemonic">{{Meaning_Mnemonic}}</div>
	<div id="meaning-hint">
		<div class="mnemonic-hint">
			<p class="hint"><img src="_hint.png" width="12" height="12">
			<b style="vertical-align: top">HINTS</b><br></p>{{Meaning_Hint}}
		</div>
	</div>
</div>

<!--Reading Section-->
<!--For: Kanji, Vocabulary-->

<div id=section-reading>
	Reading<hr>
	<div id=vocabulary-reading>{{Reading}}</div>
	<div id=kanji-readings>
		<div id=reading-container>
			<div id=onyomi-readings>On’yomi<br>{{Reading_Onyomi}}</div>
			<div id=kunyomi-readings>Kun’yomi<br>{{Reading_Kunyomi}}</div>
			<div id=nanori-readings>Nanori<br>{{Reading_Nanori}}</div>
		</div>
	</div>
	<div id="reading-audios">{{Audio}}</div>
	<p class="explanation">Explanation</p>
	<div class="mnemonic">{{Reading_Mnemonic}}</div>
	<div id="reading-hint">
		<div class="mnemonic-hint">
			<p class="hint"><img src="_hint.png" width="9" height="9">
			<b>HINTS</b><br></p>{{Reading_Hint}}
		</div>
	</div>
</div>

<!--Context Section-->
<!--For: Vocabulary-->
<div id=section-context>
	Context<hr>
	<div id="context-patterns">
		<div id="patterns-of-use">
			<p class="explanation">Patterns of Use</p>
		</div>
		<div id="common-word-combinations">
			<p class="explanation">Common Word Combinations</p>
		</div>
	</div>
	<p class="explanation">Context Sentences</p>
	<div id="context-sentences"></div>
</div>

<!--Box Section-->
<!--For: Radical, Kanji, Vocabulary-->
<div id=section-box>
	<div id=box-title></div>
	<div id=box-container></div>
</div>

<!--Found in Vocabulary Section-->
<!--For: Kanji-->
<div id=section-found-in-vocabulary>
	Found in Vocabulary<hr>
	<div id=found-in-vocabulary-container></div>
</div>

</div> <!-- id=card-back -->

<!--SCRIPT: Slice meanings and insert into the Meaning Section.-->
<script>
{
  let title = 'Meaning<hr>';
  if (card.type === 'Radical') title = 'Name<hr>';
  const div = document.getElementById('meaning-title');
  let element = document.createElement('p');
  element.innerHTML = title;
  div.appendChild(element);

  const meanings = `{{Meaning}}`;
  const array = meanings.split(',');
  const primary = array[0];
  const alternative = array.splice(1);
  const wordtype = `{{Word_Type}}`;

  const divMeanings = document.getElementById('meanings');
  element = document.createElement('p');
  element.innerHTML = `<b>PRIMARY </b>${primary.toString().toUpperCase()}`;
  divMeanings.appendChild(element);

  if (alternative.toString().length !== 0) {
    element = document.createElement('p');
    element.innerHTML = `<b>ALTERNATIVE </b>${alternative.toString().toUpperCase()}`;
    divMeanings.appendChild(element);
  }

  if (wordtype.toString().length !== 0) {
    element = document.createElement('p');
    element.innerHTML = `<b>WORD TYPE </b>${wordtype.toString().toUpperCase()}`;
    divMeanings.appendChild(element);
  }
}
</script>

<!--SCRIPT: Disable unused Reading divisions.-->
<script>
{
  if (card.type === 'Kana_Vocabulary') {
    if (preferences.pitchAccent) {
      document.getElementsByClassName('explanation')[1].style.display = 'none';
    } else {
      const audioDiv = document.getElementById('reading-audios');
      document.getElementsByClassName('explanation')[0].before(audioDiv);
    }
  }

  const disable_reading_div = (id, readings) => {
    const div = document.getElementById(id);
    if (readings === '') div.style.display = 'none';
    else div.style.display = '';
  };

  disable_reading_div('onyomi-readings', `{{Reading_Onyomi}}`);
  disable_reading_div('kunyomi-readings', `{{Reading_Kunyomi}}`);
  disable_reading_div('nanori-readings', `{{Reading_Nanori}}`);
}
</script>

<!--SCRIPT: Disable unused Hint divisions.-->
<script>
{
  const disable_hint_div = (id, readings) => {
    const div = document.getElementById(id);
    if (readings === '') div.style.display = 'none';
    else div.style.display = '';
  };

  disable_hint_div('meaning-hint', `{{Meaning_Hint}}`);
  disable_hint_div('reading-hint', `{{Reading_Hint}}`);
}
</script>

<!--SCRIPT: Slice and add Context Patterns.-->
<script>
{
  const combinations = `{{Context_Patterns}}`;
  const combinationsarray = combinations.split('|');

  for (let i = 1; i < 6; i += 2) {
    const div = document.getElementById('common-word-combinations');
    const element = document.createElement('p');
    const val1 = combinationsarray[0].split(';')[i];
    const val2 = combinationsarray[0].split(';')[i + 1];
    if (val1 === undefined) element.innerHTML = '<br>';
    else element.innerHTML = `<ja>${val1}</ja><br>${val2}`;
    element.setAttribute('id', i);
    div.appendChild(element);
  }

  for (let i = 0; i < combinationsarray.length; i++) {
    const div = document.getElementById('patterns-of-use');
    const element = document.createElement('div');
    const val = combinationsarray[i].split(';')[0];
    element.innerHTML = `<button class=notclicked id=button name='${i}' onclick='Click()'>${val}</button><br>`;
    div.appendChild(element);
  }

  const element = document.getElementsByName('0')[0];
  element.classList.add('notclicked');
  element.classList.add('clicked');

  window.Click = () => {
    const z = event.target.name;

    for (let i = 0; i < combinationsarray.length; i++) {
      const el = document.getElementsByName(i)[0];
      el.classList.remove('clicked');
      el.classList.add('notclicked');
    }

    const el = document.getElementsByName(event.target.name)[0];
    el.classList.add('clicked');
    el.classList.remove('notclicked');

    for (let i = 1; i < combinationsarray[z].length; i += 2) {
      const val1 = combinationsarray[z].split(';')[i];
      const val2 = combinationsarray[z].split(';')[i + 1];
      const targetEl = document.getElementById(i);
      if (val1 === undefined) targetEl.innerHTML = ' ';
      else targetEl.innerHTML = `<ja>${val1}</ja><br>${val2}`;
    }
  };

  if (combinations.length === 0) {
    document.getElementById('context-patterns').innerHTML = ' ';
  }
}
</script>

<!--SCRIPT: Slice and add context sentences.-->
<script>
{
  if (card.type === 'Vocabulary' || card.type === 'Kana_Vocabulary') {
    const sentences = `{{Context_Sentences}}`;
    const array = sentences.split('|');
    const div = document.getElementById('context-sentences');

    const appendContextSentence = (en, jp) => {
      if (jp !== '') {
        const element = document.createElement('p');
        element.innerHTML = `<p><ja>${jp}</ja><br>${en}</p>`;
        div.appendChild(element);
      }
    };

    appendContextSentence(array[0].toString(), array[1].toString());
    appendContextSentence(array[2].toString(), array[3].toString());
    appendContextSentence(array[4].toString(), array[5].toString());
  }
}
</script>

<!--SCRIPT: Disable divisions.-->
<script>
{
  const readingsection = document.getElementById('section-reading');
  const boxsection = document.getElementById('section-box');
  const contextsection = document.getElementById('section-context');
  const combinationsection = document.getElementById('section-radical-combination');
  const foundinvocabularysection = document.getElementById('section-found-in-vocabulary');

  if (card.type === 'Radical') {
    readingsection.style.display = 'none';
    contextsection.style.display = 'none';
    combinationsection.style.display = 'none';
    foundinvocabularysection.style.display = 'none';
  }
  if (card.type === 'Kanji') {
    contextsection.style.display = 'none';
  }
  if (card.type === 'Vocabulary') {
    combinationsection.style.display = 'none';
    foundinvocabularysection.style.display = 'none';
  }
  if (card.type === 'Kana_Vocabulary') {
    readingsection.style.display = 'none';
    combinationsection.style.display = 'none';
    foundinvocabularysection.style.display = 'none';
    boxsection.style.display = 'none';
  }
}
</script>

<!--SCRIPT: Populate Box Characters (Found in Kanji, Visually Similar Kanji and Kanji Composition).-->
<script>
{
  if (card.type === 'Radical') {
    if (card.foundIn.characters.length !== 0) {
      const div = document.getElementById('box-title');
      const element = document.createElement('div');
      element.innerHTML = 'Found In Kanji<hr>';
      div.appendChild(element);

      for (let i = 0; i < card.foundIn.characters.length; i++) {
        const divContainer = document.getElementById('box-container');
        const elementContainer = document.createElement('div');
        elementContainer.innerHTML = `<div id=box-character>${card.foundIn.characters[i]}<div id=box-meaning>${card.foundIn.readings[i]}<br>${card.foundIn.meanings[i]}</div></div>`;
        addWKListener(elementContainer, 'kanji', card.foundIn.characters[i]);
        divContainer.appendChild(elementContainer);
      }
    }
  } else if (card.type === 'Kanji') {
    if (card.similar.characters.length !== 0) {
      const div = document.getElementById('box-title');
      const element = document.createElement('div');
      element.innerHTML = 'Visually Similar Kanji<hr>';
      div.appendChild(element);

      for (let i = 0; i < card.similar.characters.length; i++) {
        const divContainer = document.getElementById('box-container');
        const elementContainer = document.createElement('div');
        elementContainer.innerHTML = `<div id=box-character>${card.similar.characters[i]}<div id=box-meaning>${card.similar.readings[i]}<br>${card.similar.meanings[i].toString().substring(0, 15)}</div></div>`;
        addWKListener(elementContainer, 'kanji', card.similar.characters[i]);
        divContainer.appendChild(elementContainer);
      }
    }
  } else if (card.type === 'Vocabulary') {
    if (card.components.characters.length !== 0) {
      const div = document.getElementById('box-title');
      const element = document.createElement('div');
      element.innerHTML = 'Kanji Composition<hr>';
      div.appendChild(element);

      for (let i = 0; i < card.components.characters.length; i++) {
        const divContainer = document.getElementById('box-container');
        const elementContainer = document.createElement('div');
        elementContainer.innerHTML = `<div id=box-character>${card.components.characters[i]}<div id=box-meaning>${card.components.readings[i]}<br>${card.components.meanings[i].toString().substring(0, 15)}</div></div>`;
        addWKListener(elementContainer, 'kanji', card.components.characters[i]);
        divContainer.appendChild(elementContainer);
      }
    }
  }
}
</script>

<!--SCRIPT: Add Radical Combination Characters.-->
<script>
{
  if (card.type === 'Kanji') {
    for (let i = 0; i < card.components.meanings.length; i++) {
      const div = document.getElementById('combination');
      const element = document.createElement('div');

      element.innerHTML = `<radical-combination>${card.components.characters[i]}</radical-combination>${card.components.meanings[i].toString().substring(0, 15)}`;
      addWKListener(element, 'radicals', card.components.meanings[i]);
      div.appendChild(element);

      if (i + 1 !== card.components.characters.length) {
        const elementPlus = document.createElement('p');
        elementPlus.innerHTML = '<div class=combination-plus><b>+</b></div>';
        div.appendChild(elementPlus);
      }
    }
  }
}
</script>

<!--SCRIPT: Add Found in Vocabulary Characters.-->
<script>
{
  if (card.type === 'Kanji') {
    for (let i = 0; i < card.foundIn.characters.length; i++) {
      const div = document.getElementById('found-in-vocabulary-container');
      const element = document.createElement('div');
      element.innerHTML = `<div id=found-in-vocabulary-box><div class=found-in-voc>${card.foundIn.characters[i]}</div><div class=found-in-voc-reading>${card.foundIn.readings[i]}<br>${card.foundIn.meanings[i]}</div></div>`;
      addWKListener(element, 'vocabulary', card.foundIn.characters[i]);
      div.appendChild(element);
    }

    if (card.foundIn.characters.length === 0) {
      const foundinvocabularysection = document.getElementById('section-found-in-vocabulary');
      foundinvocabularysection.style.display = 'none';
    }
  }
}
</script>

<!--SCRIPT: Check the answer.-->
<script>
{
  const mainDiv = document.getElementById('main-input');
  if (mainDiv) {
    let mainInput = (sessionStorage.getItem('mainAnswer') || '').trim();
    if (!mainInput) {
      const typeans = document.getElementById('typeans');
      if (typeans) {
        typeans.innerHTML = typeans.innerHTML.replace(/<br.*/, '');
        typeans.querySelectorAll('.typeGood, .typeBad').forEach((e) => {
          if (e.innerHTML === '-' || e.innerHTML === ' ') return;
          mainInput += e.innerHTML;
        });
        if (card.face === 'Reading') {
          mainInput = wanakana.toHiragana(`${mainInput} `, { IMEMode: true }).trim();
        }
      }
    }
    const mainAnswer = sanitizeInput(mainInput);

    let correctAnswers = [];
    if (card.face === 'Meaning') {
      correctAnswers = card.meaningWhitelist;
    } else if (card.face === 'Reading') {
      correctAnswers = card.readingWhitelist;
    }

    const mainAnswerDiv = document.createElement('div');
    mainAnswerDiv.classList.add('answer-display');
    mainAnswerDiv.innerText = mainInput;
    if (card.face === 'Reading') {
      mainAnswerDiv.style.fontFamily = 'Hiragino Kaku Gothic Pro W3';
    }

    const mainAnswers = preferences.allowMultipleAnswers
      ? parseList(mainAnswer)
      : [mainAnswer];
    let mainIncorrect = [];

    if (mainInput === '') {
      mainAnswerDiv.style.display = 'none';
    } else if (mainAnswers.some(ans => correctAnswers.includes(ans))) {
      mainAnswerDiv.classList.add('correct');
      mainIncorrect = mainAnswers.filter(ans => !correctAnswers.includes(ans));
    } else {
      mainAnswerDiv.classList.add('incorrect');
    }

    mainDiv.replaceWith(mainAnswerDiv);
    sessionStorage.setItem('mainAnswer', '');

    const optionalDiv = document.getElementById('optional-input');
    let optionalIncorrect = [];

    if (optionalDiv) {
      const optionalInput = (sessionStorage.getItem('optionalAnswer') || '').trim();
      const optionalAnswer = sanitizeInput(optionalInput);

      const optionalAnswerDiv = document.createElement('div');
      optionalAnswerDiv.classList.add('answer-display');
      optionalAnswerDiv.innerText = optionalInput;

      const optionalAnswers = preferences.allowMultipleAnswers
        ? parseList(optionalAnswer)
        : [optionalAnswer];

      if (optionalInput === '') {
        optionalAnswerDiv.style.display = 'none';
      } else if (optionalAnswers.some(ans => card.meaningWhitelist.includes(ans))) {
        optionalAnswerDiv.classList.add('correct');
        optionalIncorrect = optionalAnswers.filter(ans => !card.meaningWhitelist.includes(ans));
      } else {
        optionalAnswerDiv.classList.add('incorrect');
      }

      optionalDiv.replaceWith(optionalAnswerDiv);
      sessionStorage.setItem('optionalAnswer', '');
    }

    if (mainIncorrect.length > 0 || optionalIncorrect.length > 0) {
      let msg = '';
      if (mainIncorrect.length > 0) {
        msg += `Wrong ${card.face}: ${mainIncorrect.join(', ')}`;
      }
      if (mainIncorrect.length > 0 && optionalIncorrect.length > 0) {
        msg += '\n';
      }
      if (optionalIncorrect.length > 0) {
        msg += `Wrong Meaning: ${optionalIncorrect.join(', ')}`;
      }
      showToast(msg, true);
    }
  }
}
</script>

<!-- Generate tooltips -->
<script>
{
  const setTooltips = (tags, text) => {
    for (let i = 0; i < tags.length; i++) {
      tags[i].setAttribute('title', text);
    }
  };

  const kanji = document.getElementsByTagName('kanji');
  const radicals = document.getElementsByTagName('radical');
  const vocab = document.getElementsByTagName('vocabulary');
  const reading = document.getElementsByTagName('reading');

  setTooltips(kanji, 'Kanji');
  setTooltips(radicals, 'Radical');
  setTooltips(vocab, 'Vocabulary');
  setTooltips(reading, 'Reading');
}
</script>

<!-- Pitch Accent Info -->
<script>
{
  if (preferences.pitchAccent && (card.type === 'Vocabulary' || card.type === 'Kana_Vocabulary')) {
    const readings = parseList(`{{Reading}}`);
    const readingsContainer = document.createElement('div');
    readingsContainer.id = 'vocabulary-readings-container';

    readings.forEach((r, i) => {
      const div = document.createElement('div');
      div.id = `reading-${i + 1}`;
      div.classList.add('vocabulary-reading-entry');
      div.innerHTML = r;
      readingsContainer.appendChild(div);
    });
    const vocabReading = document.getElementById('vocabulary-reading');
    vocabReading.innerHTML = '';
    vocabReading.appendChild(readingsContainer);

    const readingsection = document.getElementById('section-reading');
    readingsection.style.display = 'block';

    const SHOW_PITCH_DESCRIPTION = true;
    const SQUASH_DIGRAPHS = false;
    const DOT_RADIUS = 0.2;
    const STROKE_WIDTH = 0.1;
    const WEB_URL = 'https://www.gavo.t.u-tokyo.ac.jp/ojad/search/index/curve:fujisaki/word:%s';

    const digraphs = 'ぁぃぅぇぉゃゅょゎゕゖァィゥェォャュョヮヵヶ';
    let pitchLookup = null;

    const patternObj = {
      heiban: {
        name: '平板',
        nameEng: 'heiban',
        cssClass: 'heiban',
        color: '#d20ca3'
      },
      odaka: {
        name: '尾高',
        nameEng: 'odaka',
        cssClass: 'odaka',
        color: '#0cd24d'
      },
      nakadaka: {
        name: '中高',
        nameEng: 'nakadaka',
        cssClass: 'nakadaka',
        color: '#27a2ff'
      },
      atamadaka: {
        name: '頭高',
        nameEng: 'atamadaka',
        cssClass: 'atamadaka',
        color: '#EA9316'
      },
      unknown: {
        name: '不詳',
        nameEng: 'No pitch value found, click the number for more info.',
        cssClass: 'unknown',
        color: '#CCCCCC'
      }
    };
    const JAPANESE_TO_WORD_TYPE = {
      名: 'Noun',
      代: 'Pronoun',
      副: 'Adverb',
      形動: 'な Adjective',
      感: 'Interjection'
    };

    const getMoraCount = (reading) => {
      return [...reading].filter(c => !digraphs.includes(c)).length;
    };

    const getPitchType = (pitchNum, moraCount) => {
      if (pitchNum === 0) return patternObj.heiban;
      if (pitchNum === 1) return patternObj.atamadaka;
      if (pitchNum === moraCount) return patternObj.odaka;
      if (pitchNum < moraCount) return patternObj.nakadaka;
      return patternObj.unknown;
    };

    const drawPitchDiagram = (pitchNum, reading) => {
      const moraCount = getMoraCount(reading);
      const width = SQUASH_DIGRAPHS ? moraCount : reading.length;
      const patternType = getPitchType(pitchNum, moraCount);

      const namespace = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(namespace, 'svg');
      svg.setAttribute('viewBox', `-0.5 -0.25 ${width + 1} 1.5`);

      const xCoords = [];
      for (let i = 0; i <= reading.length; i++) {
        if (!SQUASH_DIGRAPHS && digraphs.includes(reading[i])) {
          xCoords[xCoords.length - 1] += 0.5;
        } else {
          xCoords.push(i);
        }
      }

      let yCoords = new Array(moraCount + 1).fill(null);
      yCoords = yCoords.map((_, i) => {
        if (pitchNum === 0) return i === 0 ? 1 : 0;
        if (i + 1 === pitchNum) return 0;
        if (i === 0) return 1;
        return i < pitchNum ? 0 : 1;
      });
      const points = yCoords.map((y, i) => ({ x: xCoords[i], y }));

      const polyline = document.createElementNS(namespace, 'polyline');
      polyline.setAttribute('fill', 'none');
      polyline.setAttribute('stroke', patternType.color);
      polyline.setAttribute('stroke-width', STROKE_WIDTH);
      polyline.setAttribute(
        'points',
        points.map(p => `${p.x},${p.y}`).join(' ')
      );
      svg.appendChild(polyline);

      points.forEach((p, i) => {
        const isParticle = i === points.length - 1;
        const circle = document.createElementNS(namespace, 'circle');
        circle.setAttribute(
          'fill',
          isParticle ? '#eeeeee' : patternType.color
        );
        circle.setAttribute(
          'stroke',
          isParticle ? 'black' : patternType.color
        );
        circle.setAttribute(
          'stroke-width',
          isParticle ? STROKE_WIDTH / 2 : 0
        );
        circle.setAttribute('cx', p.x);
        circle.setAttribute('cy', p.y);
        circle.setAttribute('r', DOT_RADIUS);
        svg.appendChild(circle);
      });
      const p = document.createElement('p');
      p.classList.add('pitch-diagram');
      p.lang = 'ja';
      p.appendChild(svg);
      return p;
    };

    const generatePatternText = (pitchNum, vocab, reading) => {
      const moraCount = getMoraCount(reading);
      const patternType = getPitchType(pitchNum, moraCount);
      const sName = document.createElement('span');
      const aLink = document.createElement('a');
      aLink.href = WEB_URL.replace('%s', vocab);
      aLink.target = '_blank';
      aLink.title = `Pitch Pattern: ${patternType.nameEng} (${patternType.name})`;
      aLink.textContent = `[${pitchNum}]`;
      sName.textContent = `${patternType.name} `;
      sName.classList.add(patternType.cssClass);
      sName.appendChild(aLink);
      return sName;
    };

    const makeMonospaced = (textNode) => {
      let chars = [...textNode.textContent];
      if (SQUASH_DIGRAPHS) {
        chars.forEach((c, i, a) => {
          if (digraphs.includes(c)) a[i - 1] += c;
        });
        chars = chars.filter(c => !digraphs.includes(c));
      }
      const spans = chars.map((c) => {
        const span = document.createElement('span');
        span.textContent = c;
        span.classList.toggle('digraph', c.length > 1);
        return span;
      });
      textNode.replaceWith(...spans);
    };

    const pitchToInfoElements = (pitch, vocab, reading) => {
      return pitch.map((p, i) => [
        i === 0 ? '' : ' or ',
        generatePatternText(p, vocab, reading)
      ]).reduce((acc, val) => acc.concat(val), []);
    };

    const pitchByWordTypeToInfoElements = (wordTypeToPitch, vocab, reading) => {
      const result = wordTypeToPitch.map(([wordType, pitch]) => [
        `${JAPANESE_TO_WORD_TYPE[wordType]}: `,
        ...pitchToInfoElements(pitch, vocab, reading),
        ', '
      ]).reduce((acc, val) => acc.concat(val), []);
      result.pop();
      return result;
    };

    const appendPitchPatternInfo = (readingElement, infoElements) => {
      if (!SHOW_PITCH_DESCRIPTION) return null;
      const dInfo = document.createElement('div');
      const hInfo = document.createElement('h3');
      const pInfo = document.createElement('p');
      hInfo.textContent = 'Pitch Pattern';
      dInfo.classList.add('pitch-pattern');
      pInfo.append(...infoElements);
      dInfo.append(hInfo, pInfo);
      readingElement.after(dInfo);
      return dInfo;
    };

    const pitchLookupObject = (vocab, reading, lookupObject) => {
      return lookupObject[`${vocab}|${reading}`];
    };

    const loadPitchInfo = () => {
      if (pitchLookup) return pitchLookup;

      const lookupObject = JSON.parse(`{{Pitch_Accent}}`);
      pitchLookup = (vocab, reading) =>
        pitchLookupObject(vocab, reading, lookupObject);
      return pitchLookup;
    };

    const getPitchInfo = (vocab, reading) => {
      const lookup = loadPitchInfo();
      let result = lookup(vocab, reading);
      if (!result) {
        result = lookup(
          vocab.replace(/する$/, ''),
          reading.replace(/する$/, '')
        );
      }
      if (!result) {
        result = lookup(wanakana.toHiragana(vocab), wanakana.toHiragana(reading));
      }
      if (!result) {
        result = lookup(wanakana.toKatakana(vocab), wanakana.toKatakana(reading));
      }
      return result;
    };

    const injectPitchInfo = () => {
      document.querySelectorAll('.vocabulary-reading-entry').forEach(pReading => {
        const reading = pReading.textContent;
        const pitchInfo = getPitchInfo(card.characters, reading);
        if (!pitchInfo) return;

        const regex = /[(;]([^);]*)/g;
        let match;
        const matches = [];
        while ((match = regex.exec(pitchInfo)) !== null) matches.push(match[1]);
        const wordTypes = [...new Set(matches)];

        let parsedPitchInfo = [];
        if (wordTypes.length > 0) {
          const wordTypeToPitch = wordTypes.map((w) => {
            const regexInner = new RegExp(`${w}[^\\)]*\\)([\\d,]+)`, 'g');
            let matchInner;
            const matchesInner = [];
            while ((matchInner = regexInner.exec(pitchInfo)) !== null) matchesInner.push(matchInner[1]);
            return [
              w,
              matchesInner.join('')
              .split(',')
              .filter((p) => p)
              .map((p) => parseInt(p))
            ];
          });
          appendPitchPatternInfo(pReading, pitchByWordTypeToInfoElements(wordTypeToPitch, card.characters, reading));

          const matchesDigits = [];
          const regexDigits = /\d/g;
          while ((match = regexDigits.exec(pitchInfo)) !== null) matchesDigits.push(match[0]);
          parsedPitchInfo = [...new Set(matchesDigits.map((r) => r))].map((p) => parseInt(p));
        } else {
          parsedPitchInfo = pitchInfo.split(',').map((p) => parseInt(p));
          appendPitchPatternInfo(
            pReading,
            pitchToInfoElements(
              parsedPitchInfo,
              card.characters,
              reading
            )
          );
        }
        const diagrams = parsedPitchInfo.map((p) => drawPitchDiagram(p, reading));
        pReading.before(...diagrams);
        makeMonospaced(pReading.childNodes[0]);
      });
    };
    injectPitchInfo();
  }
}
</script>

<!-- Show Level/Link & Play Audio -->
<script>
{
  const level = document.getElementById('level');
  level.style.display = 'inline';

  const link = document.getElementById('wk-link');
  link.style.display = 'inline';

  const autoPlay = preferences.autoPlayAudio.toLowerCase().trim();
  const audioContainer = document.getElementById('reading-audios');

  if (autoPlay && audioContainer) {
    const audios = audioContainer.querySelectorAll('.replay-button');
    const female = audios[0];
    const male = audios[1];

    switch (autoPlay) {
      case 'female':
        if (female) female.click();
        break;
      case 'male':
        if (male) male.click();
        break;
      case 'both':
        if (female) female.click();
        if (male) setTimeout(() => male.click(), 1000);
        break;
    }
  }
}
</script>
